<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ORM框架之SQLAlchemy]]></title>
    <url>%2F2018%2F12%2F03%2FORM%E6%A1%86%E6%9E%B6%E4%B9%8BSQLAlchemy%2F</url>
    <content type="text"><![CDATA[因本文尚未整理出来，故纯属占坑]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>mysql</tag>
        <tag>SQLAlchemy</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pymysql及相关拓展]]></title>
    <url>%2F2018%2F12%2F02%2Fpymysql%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[注：本文部分引自博客园苍松 pymysqlpymysql是python用于连接并操作数据库的一个原生模块 pymysql安装linux下: pip3 install pymysql sql注入1.简单模拟登录先来看一个简单例子，代码如下： import pymysql user = input(&quot;username:&quot;) pwd = input(&quot;password:&quot;) # 与数据库建立连接 conn = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;root&quot;, database=&quot;test&quot;) # 设置游标 cursor = conn.cursor() # 将要执行的sql语句 sql = &quot;select * from userinfo where username = &apos;%s&apos; and password = &apos;%s&apos;&quot; % (user, pwd) # 执行语句 cursor.execute(sql) # 用fetchone获取查询结果 result = cursor.fetchone() # 关闭连接 cursor.close() conn.close() if result: print(&quot;登录成功&quot;) else: print(&quot;用户名或密码错误&quot;) 2.sql注入漏洞注意，上面的代码虽然可正确执行，但是是存在漏洞的。如图，漏洞为即使你随便输入一个账户，按照”xxx’ or 1=1 – “的格式，不输入密码也能登录进去，这种漏洞我们称呼为”sql注入”；问题主要存在于sql语句的写法。 3.sql注入原理如图 4.避免sql注入为了避免sql注入，我们不要自己做拼接，用pymysql自带的execute后面传参数的方式,有如下三种方法: sql = &quot;select * from userinfo where username = %s and password = %s&quot; cursor.execute(sql, (user, pwd)) 或者： sql = &quot;select * from userinfo where username = %s and password = %s&quot; cursor.execute(sql, [user, pwd]) 或者： sql = &quot;select * from userinfo where username = %(u)s and password = %(p)s&quot; cursor.execute(sql, {&apos;u&apos;: user, &apos;p&apos;: pwd}) 顺利解决sql注入问题，如图 5.模拟登陆代码import pymysql name = input(&quot;username:&quot;) pwd = input(&quot;password:&quot;) conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, database=&apos;test&apos;) cursor = conn.cursor() sql = &quot;select * from userinfo where name=%s and password=%s&quot; r = cursor.execute(sql, (name, pwd)) # 方法二 # sql = &quot;select * from userinfo where name=%s and password=%s&quot; # r = cursor.execute(sql, [name, pwd]) # 方法三 # sql = &quot;select * from userinfo where name=%(u)s and password=%(p)s&quot; # r = cursor.execute(sql, {&apos;u&apos;: name, &apos;p&apos;: pwd}) result = cursor.fetchone() cursor.close() conn.close() if result: print(&quot;登陆成功&quot;) else: print(&quot;账户名或密码错误&quot;) pymysql操作数据库1.pymysql增1.1.插入一行数据 代码如下： import pymysql conn = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;root&quot;, database=&quot;test&quot;) cursor = conn.cursor() sql = &quot;insert into userinfo(username,password) values(&apos;那英&apos;,&apos;naying&apos;)&quot; cursor.execute(sql) conn.commit() cursor.close() conn.close() 值得注意的是，在增删改时我们用的是commit进行提交，在查时用的是fetchone进行查找。当然，我们也可以自定义插入，如下： sql = &quot;insert into userinfo(username,password) values(%s,%s)&quot; cursor.execute(sql, [user, pwd]) conn.commit() 1.2.插入多行数据 在插入当行数据是，应注意此时我们用的是executemany，而不是execute。 sql = &quot;insert into userinfo(username,password) values(%s,%s)&quot; r = cursor.executemany(sql, [(&apos;张学友&apos;, &apos;zhangxueyou&apos;), (&apos;林俊杰&apos;, &apos;linjunjie&apos;)]) conn.commit() 1.3.execute的返回值r execute和executemany都有返回值，用来记录受影响的行数，如下： sql = &quot;insert into userinfo(username,password) values(%s,%s)&quot; r = cursor.executemany(sql, [(&apos;张学友&apos;, &apos;zhangxueyou&apos;), (&apos;林俊杰&apos;, &apos;linjunjie&apos;)]) print(r) conn.commit() 结果为2；不仅仅是增删改会有受影响的行数，查询时也会有。同时，executemany只适用于插入数据，删和改用execute即可。 2.pymysql查2.1.fetchone 代码如下： result = cursor.fetchone() print(result) result = cursor.fetchone() print(result) result = cursor.fetchone() print(result) 结果： (1, &apos;刘德华&apos;, &apos;liudehua&apos;) (3, &apos;郭德纲&apos;, &apos;guodegang&apos;) (4, &apos;胡歌&apos;, &apos;huge&apos;) fetchone可以单次查询，也可以连续单次查询，连续单次查询时，会有类似于指针一样的东西，当你查询一次后，指针自动跳往下一行数据。 2.2.fetchall fetchall在未指定limit时，默认查询所有数据代码如下： sql = &quot;select * from userinfo&quot; cursor.execute(sql) result = cursor.fetchall() print(result) 结果：((1, ‘刘德华’, ‘liudehua’), (3, ‘郭德纲’, ‘guodegang’), (4, ‘胡歌’, ‘huge’), (5, ‘周杰伦’, ‘zhoujielun’), (7, ‘那英’, ‘naying’), (8, ‘王菲’, ‘wangfei’), (11, ‘张学友’, ‘zhangxueyou’), (14, ‘林俊杰’, ‘linjunjie’)) 2.3.fetchmany fetchmany(n)查询指定前n条数据代码如下： sql = &quot;select * from userinfo&quot; cursor.execute(sql) result = cursor.fetchmany(3) print(result) 结果：((1, ‘刘德华’, ‘liudehua’), (3, ‘郭德纲’, ‘guodegang’), (4, ‘胡歌’, ‘huge’)) 2.4.fetch小结 1.fetchone查询单次数据，fetchall查询所有数据，fetchmany(n)查询指定n词数据。2.如果想要实现分页的话，要先在查询语句中limit 10数据，再用fetchall查询指定的10条数据；而不能先fetchall所有数据，再一部分一部分的显示。3.相对来说，用的最多的是fetchone和fetchall 注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如： cursor.scroll(1,mode=’relative’) # 相对当前位置移动cursor.scroll(2,mode=’absolute’) # 相对绝对位置移动 2.5.查询数据字典形式显示 为了方便查看，我们会将数据以字典格式显示key和value代码如下： import pymysql conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, database=&apos;test&apos;) cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = &quot;select * from userinfo&quot; cursor.execute(sql) result = cursor.fetchmany(3) print(result) 结果：[{‘id’: 1, ‘username’: ‘刘德华’, ‘password’: ‘liudehua’}, {‘id’: 3, ‘username’: ‘郭德纲’, ‘password’: ‘guodegang’}, {‘id’: 4, ‘username’: ‘胡歌’, ‘password’: ‘huge’}] 2.6.新增数据的自增id 获取新增数据的自增id:cursor.lastrowid,直接用如果插入的为多行数据，则显示的为最后一个自增的id print(cursor.lastrowid) 3.pymysql删改增和查的注意点可能多一点，而pymysql删与改的操作重点在于sql语句，其他只需要连接，执行，关闭连接即可。 3.1.改 代码如下： import pymysql conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, database=&apos;test&apos;) cursor = conn.cursor() sql = &quot;update userinfo set name=&apos;李玉刚&apos; where id=1&quot; cursor.execute(sql) conn.commit() cursor.close() conn.close() 4.pymysql删4.1.删 代码如下： import pymysql conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, database=&apos;test&apos;) cursor = conn.cursor() sql = &quot;delete from userinfo where id=1&quot; cursor.execute(sql) conn.commit() cursor.close() 视图为某个查询语句设置别名，方便使用，即为视图； 1.创建视图创建语句：create view viewname as SQLeg： CREATE view v1 as SELECT * FROM userinfo WHERE id&gt;5; CREATE view v1 as SELECT id,name FROM userinfo WHERE id&gt;5; 2.修改视图修改语句：alter view viewname as SQLeg： alter view v1 as SELECT id,NAME from userinfo WHERE id &gt;5; 3.删除视图删除语句：drop view viewname;eg： drop view v1; 4.查看视图查看语句：select from viewname;eg: select from v1; select id,name from v1; 5.视图小结给一个临时表设置别名的过程就叫做创建视图，别名就是视图的名称；实际存在的表比如userinfo就是物理表，而一个视图就是虚拟表，虚拟表动态的从物理表中取数据，所以在物理表中插入数据后虚拟表也可能会随之改变，但不能向虚拟表中插入数据；创建，修改，删除视图。 触发器对某个表进行【增/删/改】操作的前后触发一些操作即为触发器，如果希望触发增删改的行为之前或之后做操作时，可以使用触发器，触发器用于自定义用户对表的行进行【增/删/改】前后的行为。 1.创建触发器delimiter // # 修改终止符 CREATE TRIGGER tri_before_insert_userinfo BEFORE INSERT on userinfo for EACH ROW BEGIN insert into userinfolog(type,newname) VALUES(&apos;insert&apos;,&apos;姓名&apos;); END// delimiter ; # 结束后将终止符修改回来 2.多次触动触发器insert into userinfo(name,password) values(&apos;石超&apos;,&apos;shichao&apos;),(&apos;林殊&apos;,&apos;linshu&apos;); 因为each row的存在，在一次SQL中插入两行数据，会触发两次触发器，即向userinfo插入数据前，会分别两次向user插入数据。 3.自定义触发器新插入数据在前面我们写的触发器里，只能插入固定的数据，那么我们可不可以在user中插入即将插入userinfo的数据呢？答案是可以的，如下： delimiter // create trigger tri_after_delete_userinfo after delete on userinfo for each row begin insert into userinfolog(type,oldname) values(‘delete’,OLD.name); end // delimiter ; delimiter // create trigger tri_after_update_userinfo after update on userinfo for each row begin insert into userinfolog(type,oldname,newname) values(&apos;update&apos;,OLD.name,NEW.name); end // delimiter ; 注意：触发器无法被修改，如果想要修改的话，可以先drop，再重新创建 delimiter // create trigger tri_after_update_userinfo after insert on userinfo for each row begin if NEW.operate = &apos;insert&apos; then insert into userinfolog(type,newname) values(&apos;INSERT&apos;,NEW.name); elseif NEW.operate = &apos;delete&apos; then insert into userinfolog(type,newname) values(&apos;delete&apos;,OLD.name); else insert into userinfolog(type,oldname,newname) values(&apos;update&apos;,OLD.name); end if; end // delimiter ; 函数1、内置函数MySQL中提供了许多内置函数，例如：CURDATE(),可以查看当前时间；使用： select CURDATE() 查看更多 2、自定义函数delimiter \\ create function f1( i1 int, i2 int) returns int BEGIN declare num int; set num = i1 + i2; return(num); END \\ delimiter ; 3、删除函数drop function func_name(); 4、执行函数# 获取返回值 set @i1=1; set @i2=2; select f1(@i1,@i2) into @j; SELECT @j; select f1(11,nid) ,name from tb2; # 在查询中使用,对列的值函数计算后返回。 5、查看函数show function status; 6、查看函数构建语句show create function func_name\G 存储过程存储过程是一个SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。 1、创建存储过程无参数存储过程 – 创建存储过程 delimiter // #修改结束符号，为// create procedure p1() BEGIN select * from t1; END// delimiter ; – 执行存储过程 call p1() 对于存储过程，可以接收参数，其参数有三类： in 仅用于传入参数用out 仅用于返回值用inout 既可以传入又可以当作返回值关于变量设置，对于调用存储过程或者函数时，外部传入参数或者获取参数，需加符号@，例如set @t=1；在本次会话内这些带@的变量都可以被获取到。断开连接后变量失效。 有参数存储过程 – 创建存储过程 delimiter \\ create procedure p1( in i1 int, in i2 int, inout i3 int, out r1 int ) BEGIN DECLARE temp1 int; DECLARE temp2 int default 0; set temp1 = 1; set r1 = i1 + i2 + temp1 + temp2; set i3 = i3 + 100; end\\ delimiter ; – 执行存储过程 SET @t2=3; CALL p1 (1, 2 ,@t1, @t2); SELECT @t1,@t2; delimiter // 将结束符号;修改为// DECLARE 声明变量。如果没有DEFAULT子句，初始值为NULL。用于内部变量申明。 SET 变量赋值。用于内部变量赋值，和传参数时参数赋值。 2、删除存储过程drop procedure proc_name; 3、执行存储过程– 无参数 call proc_name(); – 有参数，全in call proc_name(1,2); – 有参数，有in，out，inout set @t1=3; call proc_name(1,2,@t1,@t2); import pymysql conn = pymysql.connect(host=&apos;127.0.0.1&apos;,user=&apos;root&apos;, password=&apos;root&apos;, db=&apos;t1&apos;) cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) cursor.callproc(&apos;p1&apos;, args=(1, 22, 3, 4)) # 执行存储过程 cursor.execute(&quot;select @_p1_0,@_p1_1,@_p1_2,@_p1_3&quot;) # 获取执行完存储的参数 result = cursor.fetchall() conn.commit() cursor.close() conn.close() print(result) 4、查看存储过程列出所有的存储过程 SHOW PROCEDURE STATUS; 5、查看存储过程生成语句查看存储过程 SHOW CREATE PROCEDURE 存储过程名\G 事务事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。 定义存储过程： delimiter \\ drop PROCEDURE if EXISTS p1; create PROCEDURE p1( OUT p_return_code tinyint ) BEGIN DECLARE exit handler for sqlexception -- 定义错误处理 BEGIN -- ERROR set p_return_code = 1; rollback; -- 回滚 END; DECLARE exit handler for sqlwarning -- 定义告警处理 BEGIN -- WARNING set p_return_code = 2; rollback; END; START TRANSACTION; -- 开始事务，使下面的多条SQL语句操作变成原子性操作 UPDATE tb7 set licnese=(licnese-5) WHERE nid=21; UPDATE tb7 set licnese=(licnese+5) WHERE nid=22; COMMIT; -- SUCCESS set p_return_code = 0; END\\ delimiter ; 执行存储过程： call p1(@p); SELECT @p; SQL防注入之动态SQL在高级语言的DB API不提供防注入的参数化查询功能时，可以使用这种方法来防止SQL注入。在pymysql中的调用点这里。 定义存储过程： delimiter \\ DROP PROCEDURE IF EXISTS proc_sql \\ CREATE PROCEDURE proc_sql ( in nid1 INT, in nid2 INT, in callsql VARCHAR(255) ) BEGIN set @nid1 = nid1; set @nid2 = nid2; set @callsql = callsql; PREPARE myprod FROM @callsql; -- PREPARE prod FROM &apos;select * from tb2 where nid&gt;? and nid&lt;?&apos;; 传入的值为字符串，？为占位符 -- 用@nid1，和@nid2填充占位符 EXECUTE myprod USING @nid1,@nid2; DEALLOCATE prepare myprod; END\\ delimiter ; 调用存储过程 set @nid1=12; set @nid2=15; set @callsql = &apos;select * from tb7 where nid&gt;? and nid&lt;?&apos;; CALL proc_sql(@nid1,@nid2,@callsql)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>pymysql</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《精通Python网络爬虫》韦玮著]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8A%E7%B2%BE%E9%80%9APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E3%80%8B%E9%9F%A6%E7%8E%AE%E8%91%97%2F</url>
    <content type="text"><![CDATA[Urllib库与URLError异常处理1.Urllib库的改变Python2.X——-&gt;Python3.Ximport urllib2–&gt;import urllib.request,urllib.errorimport urllib–&gt;import urllib.request,urllib.erroe,urllib.parseimport urlparse–&gt;import urllib.parseurllib2.urlopen–&gt;urllib.request.urlopenurllib.urlencode–&gt;urllib.parse.urlencodeurllib.quote–&gt;urllib.request.quotecookielib.CookieJar–&gt;http:CookieJarurllib2.Request–&gt;urllib.request.Request 2.快速使用Urllib库爬取网页import urllib.request file = urllib.request.urlopen(&quot;http://www.baidu.com&quot;) data = file.read() dataline = file.readline() print(dataline) f = open(&quot;../爬取数据存储/01_4.2.html&quot;,&quot;wb&quot;) f.write(data) f.close() 注意：读取内容常见的有三种方式，其用法为：1.fiel.read()读取文件的全部内容，与readlines不同的是，read会把读取到的内容赋值给一个字符串变量2.fiel.readlines()读取文件的全部内容，与read不同的是，readlines会把读取到的内容赋值给一个列表变量，若要读取全部内容，推荐使用这种方式。3.file.readline()读取文件的一行内容。 除此之外，还可以使用urllib.request里面的urlretrieve()函数直接将对应信息写入本地文件，格式为:”urllib.request.retrieve(url,filename = 本地文件地址)” import urllib.request file = urllib.request.urlopen(&quot;http://www.baidu.com&quot;) filename = urllib.request.urlretrieve(&quot;http://edu.51cto.com&quot; , filename = &quot;../爬取数据存储/02_.html&quot;) urllib.request.urlcleanup() print(file.info()) print(file.getcode()) print(file.geturl()) 一般来说，url标准中只允许一部分ASCII字符比如数字，字母，部分符号等，而其他一些字符比如汉字等不符合标准的字符时，需要进行url编码；相应的，也可以进行解码。 urllib.request.quote(&quot;http://www.sina.com.cn&quot;) urllib.request.unquote(&quot;http%3A//www.sina.com.cn&quot;) 3.浏览器的模拟-Headers属性当网页针对请求头进行反爬虫时，我们可以设置一些Headers属性，模拟成浏览器去访问这些网站，就可以解决这个问题了。 3.1 使用build_opener()修改报头 由于urlopen()不支持一些HTTP的高级功能，所以我们要修改报头，可以使用urllib.request.build_opener()进行 import urllib.request url = &quot;https://blog.csdn.net/red_stone1/article/details/80999551&quot; headers = (&quot;User-Agent&quot;,&quot;Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)&quot;) # 创建自定义的opener对象 opener = urllib.request.build_opener() # 创建全局默认的opener对象，这样，在使用urlopen()时，也会使用我们安装的opener对象 opener.addheaders = [headers] data = opener.open(url).read().decode(&quot;utf-8&quot;) print(data) 3.2 使用add_header()添加报头 除了上面这种方法之外，还可以使用urllib.request.Request()下的add_header()实现浏览器的模拟。 import urllib.request url = &quot;https://blog.csdn.net/red_stone1/article/details/80999551&quot; # 使用add_header()添加报头 req = urllib.request.Request(url) req.add_header(&apos;User-Agent&apos;,&apos;Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)&apos;) data = urllib.request.urlopen(req).read() print(data) 4.超时设置有的时候，我们访问一个网页，如果该网站长时间未响应，那么系统就会判断该网页超时了，即无法打开该网页。有的时候，我们需要根据自己的需要来设置超时的时间值。那么就可以用到timeout了。 import urllib.request for i in range(1,100): try: file = urllib.request.urlopen(&quot;http://yum.iqianyue.com&quot;, timeout=3) data = file.read() print(len(data)) except Exceptionas as e: print(&quot;出现异常--&gt;&quot;+str(e)) 相对来说，我们最好设置一个较合理的时间值，这样的话，我们能最大程度的获取想要的信息，同时，也能减轻爬取对象的服务器压力。 5.HTTP协议请求实战http协议请求主要分为6种类型，各类型的主要作用如下：1）get请求：get请求会通过url网址传递信息，可以直接在url中写上要传递的信息，也可以由表单进行传递。如果使用表单进行传递，这表单中的信息会自动转为url地址中的数据，通过url地址传递。2）post请求：可以向服务器提交数据，是一种比较主流也比较安全的数据传递方式，比如在登录时，经常使用post请求发送资源。3）put请求：请求服务器存储一个资源，通常要指定存储的位置。4）delete请求：请求服务器删除一个资源。5）head请求：请求获取对应的http报头信息。6）options请求：可以获得当前url所支持的请求类型。这六种类型是比较比较常用的，除此之外，还有7）trace请求：主要用于测试或诊断。8）connect请求 因为TRACE用的非常少，故不再提及。相对来说，用得最多的是get请求和post请求。 5.1 get请求实例分析 import urllib.request url = &quot;http://www.baidu.com/s?wd=&quot; key = &quot;王者荣耀&quot; key = urllib.request.quote(key) fullurl = url+key request = urllib.request.Request(fullurl) data = urllib.request.urlopen(request).read() # print(data) with open(&quot;../爬取数据存储/05_百度接口.html&quot;,&quot;wb&quot;)as f: f.write(data) print(&quot;保存完成&quot;) 通过以上实例我们可以知道，如果要使用GET请求，思路如下：1）构建对应的URL地址，该URL地址包含GET请求的字段名和字段内容等信息，并且URL地址满足GET请求的格式，即“http://网址?字段名1=字段内容1&amp;字段名2=字段内容2”2）以对应的URL为参数，构建Request对象。3）通过urlopen()打开构建的Request对象。4）按需求进行后续的处理操作，比如读取网页的内容、将内容写入文件等。 5.2 POST请求实例分析 import urllib.request url = &quot;http://www.iqianyue.com/mypost/&quot; postdata = { &quot;name&quot;:&quot;hahaha&quot;, &quot;pass&quot;:&quot;xixixiix&quot;} postdata = urllib.parse.urlencode(postdata).encode(&quot;utf-8&quot;) request = urllib.request.Request(url,postdata) request.add_header(&quot;User-Agent&quot;,&quot;Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11&quot;) data = urllib.request.urlopen(request).read() with open(&quot;../爬取数据存储/07_post请求.html&quot;,&quot;wb&quot;) as f: f.write(data) print(&quot;Sava successful.&quot;) 如果我们要构造PSOT请求，实现思路如下：1）设置好URL网址。2）构建表单数据，并使用urllib.parse.urlencode对数据进行编码处理。3）构建Request对象，参数包括URL地址和要传递的数据。4）添加头部信息，模拟浏览器进行爬取。5）使用urllib.requesr.urlopen()打开对应的Request对象。完成信息的传递。6）后续处理，比如读取网页内容，将内容写入文件等。 6.代理服务器的设置有时使用同一个IP去爬取同一个网站上的网页，久了之后会被该网站服务器屏蔽。那么怎么解决这个问题呢？解决的方法很简单，“瞒天过海，暗度陈仓”，即使用代理服务器。代理ip的获取可以通过网上查找，我比较常用的是http://www.xicidaili.com/ ，我们尽量找验证时间短的，这样成功的概率会比较大，一些验证时间长的，可能会失效。 import urllib.request def use_proxy(proxy_addr,url): proxy = urllib.request.ProxyHandler({&apos;http&apos;:proxy_addr}) # 使用build_opener(),创建自定义的opener对象 opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler) urllib.request.install_opener(opener) # 使用install_opener(),创建全局默认的opener对象，这样，在使用urlopen()时，也会使用我们安装的opener对象 data = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) return data proxy_addr = &quot;120.27.14.125:80&quot; data = use_proxy(proxy_addr,&quot;http://www.baidu.com&quot;) # print(len(data)) with open(&quot;../爬取数据存储/08_代理服务器设置.html&quot;,&quot;wb&quot;)as f: f.write(data) print(&quot;保存完成&quot;) 7.DebugLog实战有时候我们希望边运行边打印调试日志，这时候需要开启DebugLog。如何开启DebugLog呢？开启思路如下：1）分别使用urllib.request.HTTPHandler()和urllib.request.HTTPSHandler()将debuglevel设置为1。2）urllib.request.build_opener()创建opener对象，并使用上一步的值为参数。3）urllib.request.install_opener()创建全局默认的opener对象，这样在使用urlopen()时会自动使用我们创建的opener对象。4）进行后续的操作，比如urlopen()等。 代码如下: import urllib.request httphd = urllib.request.HTTPHandler(debuglevel=1) httpshd = urllib.request.HTTPSHandler(debuglevel=1) opener = urllib.request.build_opener(httphd, httpshd) urllib.request.install_opener(opener) data = urllib.request.urlopen(&quot;http://www.baidu.com&quot;).read() print(data) 8.异常处理神器-URLError实战这一节主要介绍两个类，第一类是URLError类，第二类是URLError的一个子类-HTTPError类。一般来说，产生URLError的原因有如下几种可能：1）连接不上服务器2）远程URL不存在3）无网络4）触发了HTTPError初始完全处理代码： import urllib.request import urllib.error try: urllib.request.urlopen(&quot;http://www.blog.csdn.net&quot;) except urllib.error.HTTPError as e: print(e.code) print(e.reason) except urllib.error.URLError as e: print(e.reason) except Exception as e: print(&quot;发生错误:&quot; + str(e)) 优化后代码： import urllib.request import urllib.error try: urllib.request.urlopen(&quot;http://www.blog.csdn.net&quot;) except urllib.error.URLError as e: if hasattr(e, &quot;code&quot;): print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason) except Exception as e: print(&quot;发生错误:&quot; + str(e)) Cookie的使用即使我们将username和pwd进行编码传输，如果不使用Cookie，在爬取登陆后的第二个网页时，仍需登录，因为HTTP协议是一个无状态协议，我们访问了新网页，自然会话信息会消失。如果希望一直保持登录状态，则需进行cookie处理：1）导入Cookie处理模块http.cookiejar2) 使用http.cookiejar.CookieJar()创建CookieJar对象3）使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象4）创建全局默认的opener对象 import urllib.request import urllib.parse import http.cookiejar url = &quot;http://bbs.chinaunix.net/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;loginhash=LzIe6&quot; postdata = {&quot;username&quot;:&quot;weisuen&quot;, &quot;password&quot;:&quot;aA123456&quot;} postdata = urllib.parse.urlencode(postdata).encode(&quot;utf-8&quot;) request = urllib.request.Request(url, postdata) request.add_header(&apos;User-Agent&apos;, &apos;Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11&apos;) cookie = http.cookiejar.CookieJar() opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie)) urllib.request.install_opener(opener) data = opener.open(request).read() with open(&quot;../爬取数据存储/11_cookie的使用.html&quot;, &quot;wb&quot;) as f: f.write(data) print(&quot;下载完成！&quot;) url2 = &quot;http://bbs.chinaunix.net/&quot; data2 = urllib.request.urlopen(url2).read() with open(&quot;../爬取数据存储/11_cookie的使用2.html&quot;, &quot;wb&quot;) as f: f.write(data2) print(&quot;下载完成！&quot;) 小结：1）会话信息控制常用方式：通过Cookie保存会话信息，通过Session保存会话信息。2）如果是通过Session保存，会将对应信息保存在服务器端，但是服务器会给客户端发送SessionID等信息，这些信息一般存在客户端的cookie中，然后，用户在访问其他网页时，会从Cookie中读取这一部分信息，然后从服务器的Session中根据这一部分Cookie信息检索出该客户端的所有会话信息，然后进行会话控制，即就算是Session也会用到Cookie。目前来说，大部分情况还是会存储在Cookie中。3）Cookie：通过在 客户端 记录的信息确定用户的身份。Session：通过在 服务器端 记录的信息确定用户的身份。 爬虫的浏览器伪装技术有一些网站为了避免爬虫的恶意访问，会设置一些反爬虫机制，对方服务器会对爬虫进行屏蔽。常见的饭爬虫机制主要有下面几个：1.通过分析用户请求的Headers信息进行反爬虫2.通过检测用户行为进行反爬虫，比如通过判断同一个IP在短时间内是否频繁访问对应网站等进行分析3.通过动态页面增加爬虫的爬取难度，达到反爬虫的目的 解决方法：1.第一种反爬虫机制在目前网站中应用的最多，大部分反爬虫网站会对用户请求的Headers信息的“User-Agent”字段进行检测来判断身份，有时，这类反爬虫的网站还会对“Referer”字段进行检测。我们可以在爬虫中构造这些用户请求的Headers信息，以此将爬虫伪装成浏览器，简单的伪装只需设置好“User-Agent”字段的信息即可，如果要进行高相似度的浏览器伪装，则需要将用户请求的Headers信息中常见的字段都在爬虫中设置好2.第二种反爬虫机制的网站，可以通过之前学习的使用代理服务器并经常切换代理服务器的方式，一般就能够攻克限制3.第三种反爬虫机制的网站，可以利用一些工具软件，比如selenium+phantomJS，就可以攻克限制 import urllib.request import http.cookiejar url = &quot;https://stock.tuchong.com/&quot; headers = { &quot;Host&quot;: &quot; p3a.pstatp.com&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;, &quot;Accept&quot;: &quot; text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;} cookie = http.cookiejar.CookieJar() opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie)) headall = [] for key,value in headers.items(): item=(key,value) headall.append(item) opener.addheaders=headall urllib.request.install_opener(opener) data=urllib.request.urlopen(url).read() with open(&quot;../爬取数据存储/爬虫的浏览器伪装技术.html&quot;, &quot;wb&quot;) as f: f.write(data) print(&quot;下载完成！&quot;)]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>HTTP</tag>
        <tag>URLError</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑器之神-vim]]></title>
    <url>%2F2018%2F10%2F14%2FLinux%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E-vim%2F</url>
    <content type="text"><![CDATA[本节原本属于”Linux基础二”一节，但私以为本节挺重要的，也经常要用到，为方便查找使用，故单开一篇文章，记录vim的各种常用命令 编辑器:gedit,sublime,vim gedit相对来说在程序员中不怎么使用，因为没有高亮等，不适合敲代码，一般对于python程序员来说，用的较多的是sublime,pycharm,vim等 sublime:ctrl+shift+d:全选ctrl+l:选中一行也可在命令行中用subl打开sublime vim1.vi vi三种模式：命令模式（默认），编辑模式，末行模式三种模式的转换：命令模式—&gt;i,a,o,I,A,O—&gt;编辑模式—&gt;esc—&gt;命令模式命令模式—&gt;”:”—&gt;末行模式—&gt;esc—&gt;命令模式 2.命令模式转编辑模式 命令模式下：i: 插入光标前一个字符I: 插入行首a: 插入光标后一个字符A: 插入行未o: 向下新开一行,插入行首O: 向上新开一行,插入行首 3.保存编辑 在命令模式下保存，shift+z+z末行模式下：w:保存,q:退出，wq:保存退出，x:保存退出q！:不保存强制退出 4.编辑器之神-vim vim是vi的强化版，支持更多的功能，自动补全:ctrl+n 5.vim移动，跳转 命令模式：上移:k下移:j左移:h右移:lhjkl控制上下作用 M中间位置L当前屏幕的最后一行G 跳到最后1行15G 表示跳转到第15行1G 表示跳转到第1行gg 跳转到第1行vi 文件+行数：打开文件并跳转到指定行数跳转行首：ctrl+a跳转行末：ctrl+e w: 在一行中向后智能快速跳转一个单词b: 向前智能快速跳转{: 按段移动,上移}: 按段移动,下移 Ctr-d: 向下翻半屏Ctr-u: 向上翻半屏Ctr-f: 向下翻一屏Ctr-b: 向上翻一屏 6.复制，粘贴，剪切 命令模式下：yy 复制，8yy：表示从当前光标所在的行开始复制8行p 粘贴dd 剪切，8dd：表示从当前光标所在的行开始剪切8行 7.撤销反撤销 命令模式下:u 撤销ctl+r 反撤销 8.删除 命令模式下:x: 删除光标后一个字符,相当于 DelX: 删除光标前一个字符,相当于 Backspacedd: 剪切光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符d0: 删除光标前本行所有内容,不包含光标所在字符dw: 删除光标开始位置的字,包含光标所在字符 9.重复执行 命令模式下:.: 重复上一次操作的命令 10.文本行移动 命令模式下:>&gt;: 文本行右移&lt;&lt;: 文本行左移 11.可视模式 命令模式下:v: 按字符移动,选中文本V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 12.替换操作 命令模式下:r: 替换当前字符R: 替换当前行光标后的字符r +字符:直接在命令模式下修改光标下的字符 13.查找 命令模式下：/+str: 查找str再回车，n: 下一个N：上一个 14.替换命令 末行模式下，把abc全部替换成123:%s/abc/123/g末行模式下，将第一行至第10行之间的abc替换成123:1, 10s/abc/123/g 15.vim里执行 shell 下命令: 末行模式里输入!,后面跟命令]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础二]]></title>
    <url>%2F2018%2F10%2F13%2FLinux%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.压缩解压缩压缩文件：zip [-r] 目标文件(没有扩展名) 源文件解压文件：unzip -d 解压后目录文件 压缩文件eg: zip -r myzip * unzip -d ./test myzip 2.查看命令位置:which 用法：which 命令 python@ubuntu:~$ which ls /bin/ls python@ubuntu:~$ which cd python@ubuntu:~$ 注意：cd是linux内置命令，用which无法找到 3.who,whoami 查看登录用户：who查看当前用户：whoami python@ubuntu:~$ who python tty7 2018-10-13 10:12 (:0) python@ubuntu:~$ whoami python 4.ssh,ping,exit,ifconfig 远程登录：ssh 用户名＠ip退出登录：exit查看或配置网卡信息：ifconfig(win为ipconfig)检查网络：ping python@ubuntu:~$ ssh python@192.168.17.68 python@ubuntu:~$ ping 192.168.17.68 5.快速跳转行首行末 跳转行首：ctrl+a跳转行末：ctrl+e 6.用户管理:useradd,passwd,su,userdel,sudo 添加账户：useradd添加密码：passwd切换账户：su注意：su -:切换账户后还会跳转到该账户下的家目录userdel 用户名userdel -r 用户名：删除用户账号的同时删除目录获取权限：sudo，如果接下来都需要权限的话，用sudo -s python@ubuntu:~$ sudo useradd yifchan -m -d /home/yifchan [sudo] python 的密码： python@ubuntu:~$ sudo passwd yifchan 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 python@ubuntu:~$ su yifchan 密码： yifchan@ubuntu:/home/python$ python@ubuntu:~$ userdel -r yifchan 7.用户组 groupadd YYY：添加一个YYY用户组groupdel YYY：删除一个组cat /etc/group：查看有哪些用户组groups laowang表示：查看laowang所属的所有用户组usermod -g YYY laowang：把老王添加到YYY组里面usermod -a -G XXX laowang：把老王添加到XXX组里面-g 和 -G，-g指定的是默认的组useradd创建的新用户没有sudo，或者切换到root的权限，需要把这个用户添加到adm、sudo组里面才可以sudo usermod -a -G adm 用户名sudo usermod -a -G sudo 用户名 8.修改文件权限：chmod u：拥有者g：用户组o：其他人 r：read,4w：write,2x：执行,1 yifchan@ubuntu:/home/python/Desktop$ sudo chmod u-w 2.py yifchan@ubuntu:/home/python/Desktop$ ls -l 总用量 12 -rw-rw-r-- 1 python python 0 10月 11 16:46 1.py -r--r--r-- 1 root root 0 10月 13 17:34 2.py yifchan@ubuntu:/home/python/Desktop$ sudo chmod g+x 1.py yifchan@ubuntu:/home/python/Desktop$ ls -l 总用量 12 -rw-rwxr-- 1 python python 0 10月 11 16:46 1.py yifchan@ubuntu:/home/python/Desktop$ sudo chmod u=rwx,g=rwx,o=rwx 2.py yifchan@ubuntu:/home/python/Desktop$ ls -l 总用量 12 -rw-rwxr-x 1 python python 0 10月 11 16:46 1.py -rwxrwxrwx 1 root root 0 10月 13 17:34 2.py yifchan@ubuntu:/home/python/Desktop$ sudo chmod 764 2.py yifchan@ubuntu:/home/python/Desktop$ ls -l 总用量 12 -rw-rwxr-x 1 python python 0 10月 11 16:46 1.py -rwxrw-r-- 1 root root 0 10月 13 17:34 2.py root@ubuntu:~/Desktop# chmod 666 123 root@ubuntu:~/Desktop# ls -l 总用量 16 drw-rw-rw- 2 root root 4096 10月 13 18:15 123 root@ubuntu:~/Desktop/123# ls -l 总用量 0 -rw-r--r-- 1 root root 0 10月 13 18:15 1.py root@ubuntu:~/Desktop# chmod 777 123 -R root@ubuntu:~/Desktop# ls -l 总用量 16 drwxrwxrwx 2 root root 4096 10月 13 18:15 123 root@ubuntu:~/Desktop/123# ls -l 总用量 0 -rwxrwxrwx 1 root root 0 10月 13 18:15 1.py 9.chown,chgrp chown:修改文件所有者chgrp:修改文件所属组用法： chown 文件所有者 文件 chgrp 文件所属组 文件 -rwxrw-r-- 1 python root 0 10月 13 17:34 2.py root@ubuntu:~/Desktop# sudo chown python 2.py root@ubuntu:~/Desktop# ls -l 总用量 16 drwxrwxrwx 2 root root 4096 10月 13 18:15 123 -rw-rwxr-x 1 python python 0 10月 11 16:46 1.py -rwxrw-r-- 1 python root 0 10月 13 17:34 2.py root@ubuntu:~/Desktop# chgrp root 1.py root@ubuntu:~/Desktop# ls -l 总用量 16 drwxrwxrwx 2 root root 4096 10月 13 18:15 123 -rw-rwxr-x 1 python root 0 10月 11 16:46 1.py -rwxrw-r-- 1 python root 0 10月 13 17:34 2.py 10.时间日历:cal,date cal:查看日历date:单独可查看当前时间，附加其他可以用来修改时间和查看时间设置时间格式：date [MMDDhhmm[[CC]YY][.ss]] +format如：sudo date 101415562018.15,表示10月14号15时56分2018年15秒 11.进程:ps,top,kill ps:查看进程信息常用选项(选项可以不加“-”)如下：选项 含义-a 显示终端上的所有进程，包括其他用户的进程-u 显示进程的详细状态-x 显示没有控制终端的进程-w 显示加宽，以便显示更多的信息-r 只显示正在运行的进程 root@ubuntu:~/Desktop# cal root@ubuntu:~/Desktop# cal -y 2018 root@ubuntu:~/Desktop# date 2018年 10月 14日 星期日 15:47:54 CST root@ubuntu:~/Desktop# ps -aux top:动态显示进程在top命令执行后，可以按下按键得到对显示的结果进行排序：按键 含义M 根据内存使用量来排序P 根据CPU占有率来排序T 根据进程运行时间的长短来排序U 可以根据后面输入的用户名来筛选进程K 可以根据后面输入的PID来杀死进程。q 退出h 获得帮助 kill:终止进程用法：kill pid #(pid为进程序列号)kill -9 pid #绝对终止 12.关机重启:reboot、shutdown、init 命令 含义reboot 重新启动操作系统shutdown –r now 重新启动操作系统，shutdown会给别的用户提示shutdown -h now 立刻关机，其中now相当于时间为0的状态shutdown -h 20:25 系统在今天的20:25 会关机shutdown -h +10 系统再过十分钟后自动关机init 0 关机init 6 重启 13.检测磁盘空间：df,du df:检测磁盘空间df用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。选项 含义-a 显示所有文件系统的磁盘使用情况-m 以1024字节为单位显示-t 显示各指定文件系统的磁盘空间使用情况-T 显示文件系统 du:检测目录所占磁盘空间du命令用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更侧重于磁盘的使用状况。du命令的使用格式如下： du [选项] 目录或文件名选项 含义-a 递归显示指定目录中各文件和子目录中文件占用的数据块-s 显示指定文件或目录占用的数据块-b 以字节为单位显示磁盘占用情况-l 计算所有文件大小，对硬链接文件计算多次]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础一]]></title>
    <url>%2F2018%2F10%2F11%2FLinux%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.什么是操作系统如智能机器人，智能家居等，用C语言直接操作硬件，但我们用手机QQ发送消息时，QQ是应用程序，无法直接操作硬件，这个时候，操作系统就在应用程序和硬件中起媒介作用，让应用程序得以间接操作硬件。应用程序可以在操作系统上运行，操作系统可以直接操控硬件，这就是操作系统的作用。同时，操作系统支持让一个程序（如QQ）支持在不同的设备上（华为等手机）运行而不用每个品牌都有一个对应版本的QQ。 2.Linux的发展历史1969年，Ken Tompson为了能在一台闲置的电脑上运行“星际旅行”游戏，花了一个月的时间，编写出了UNIX的原型。 1970年，汤普逊在BCPL的基础上设计出了B语言，并且用B语言写出了第一个UNIX操作系统。但因为B语言的跨平台性比较差，很难移植到其他电脑上，于是他和丹尼斯(Dennis Ritchie)一起设计出了C语言，并迫不及待的用C语言完全重写了现在大名鼎鼎的UNIX。 后来因为UNIX闭源，Andrew S.Tanenbaum教授为了教学开发了MINIX(nini-UNIX)。 1991年4月，林纳斯·托瓦兹（学生）开始酝酿并着手编制自己的操作系统。1991年的10月5日，林纳斯·托瓦兹在发布消息，正式向外宣布Linux内核的诞生。而因为Linux的不断吸取广大使用者的意见进行改进，及unix和minix的版权纠纷，linux顺势崛起。 3.命令介绍页面放大：ctrl+shift+”+”页面缩小：ctrl+”-“ . 表示：当前路径..表示：当前路径的上一层路径没有…及以上，如果想要跳到上上层路径，可以使用绝对路径或者“cd../..” ls: ls:显示当前路径下的文件及文件夹的名字 ls /bin：查看根目录下的/bin文件夹下的东西 ls Document:查看当前路径下的Document下的所有东西 ls -a：查看隐藏文件 ls -l：以列表方式查看当前路径下的文件 ls -l -h：以合适的单位显示文件的大小 ls -a -l -h = ls -alh = ls -lah(作用一样) ls *.txt：显示所有以.txt结尾的文件 ls *.t?t：显示所有以.t(任意一个字符)t结尾的文件 ls *.t[xn]t：显示所有以.txt或.tnt结尾的文件 ls *.t[a-x]：同上，a-x指从a到x ls \*a：查找文件名为*a的文件 cd: cd Desktop:进入Desktop文件 cd..:返回上一级目录 cd- :返回上一次操作的目录（类似遥控中的回看） cd~：切换到当前用户的主目录(/home/用户目录) pwd:显示当前操作的路径（绝对路径）clear:清屏，也可以用快捷键ctrl+ltab键：用来自动补全touch:创建文件tree：以目录树的方式显示文件结构 输出重定向：将原来要显示的东西重新定位显示的方向 ls -ahl &gt;ls.txt：将ls -ahl命令要显示的东西在终端上不显示，覆盖式写入ls.txt中（类似于py中的”w”）。ls -ahl &gt;&gt;ls.txt：将ls -ahl命令要显示的东西在终端上不显示，追加式写入ls.txt中（类似于py中的”w+”）。 分屏显示 字符为“more”eg:more test.txt如果文件夹中的内容一屏显示不下，可以按空格键，一屏看完再看一屏；如果一屏能显示，则正常显示。但一般很少单独用more，更多的是和管道|一起用。 管道 字符为“|”eg:ls -ahl | more一次只能出现两个命令，但用管道的话，可以将ls -ahl的值暂时存储在管道中，more从管道中取值 创建文件夹 字符为“mkdir”eg:mkdir test.pymkdir A/B/C -p：递归创建A文件夹，A下创建B，B下创建C文件夹 删除文件夹 字符为“rmdir”只能删除空目录 删除文件 字符为“rm”可删除任意文件但不能删除文件夹，且不会放入回收站rm test -r,可删除文件及文件夹，递归的删rm test -i,交互的删除文件，会进行提示是否删除rm test -f, 强制的删除，忽略不存在的文件，无需提示 ln软链接与硬链接 格式： 软：ln -s 源文件 链接文件 硬：ln 源文件 链接文件eg: ln -s test.txt softlink_test.txt ln test.txt hardlink_test.txt区别：软链接相当于windows中的快捷方式，源文件被删了则软链接也无法使用；硬链接则相当于一个文件的两个名字，删除了源文件，把源文件名指向源文件的线断了，但硬链接还是指向源文件。 查看和合并文件：cat cat 01.py &gt;laowang.txt：把查看的内容copy给laozhang.txt cat 01.py 02.py：查看01.py和02.py cat 01.py 02.py &gt;laoliu.txt：把查看的两个文件的内容赋值给laoliu.txt 文本搜索：grep 选项 含义-v 显示不包含匹配文本的所有行（相当于求反）-n 显示匹配行及行号-i 忽略大小写eg: &apos;&apos;&apos; python@ubuntu:~/Desktop$ grep -n &apos;a&apos; test.txt 3:a.txt 6:java python@ubuntu:~/Desktop$ grep -n -i &apos;a&apos; test.txt 2:A 3:a.txt 6:java python@ubuntu:~/Desktop$ grep -n -v &apos;a&apos; test.txt 1:1.py 2:A 4:b.txt 5:c 7:python 8:t1.py 9:test.txt &apos;&apos;&apos; 除此之外，’’中也可以是正则表达式 查看历史命令：history 帮助文档:help,man eg:ls –helpcd –helpman ls 查找文件：find 常用用法：命令 含义find ./ -name test.sh 查找当前目录下所有名为test.sh的文件find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件find ./ -name “[A-Z]*“ 查找当前目录下所有以大写字母开头的文件find /tmp -size 2M 查找在/tmp 目录下等于2M的文件find /tmp -size +2M 查找在/tmp 目录下大于2M的文件find /tmp -size -2M 查找在/tmp 目录下小于2M的文件find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件find ./ -perm 0777 查找当前目录下权限为 777 的文件或目录 grep和find的差别是，grep是查找文件中的内容，而find是查找文件 拷贝：cp 常用用法-a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。-f 已经存在的目标文件而不提示-i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认-r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。-v 显示拷贝进度eg:cp a/* b -r:拷贝a文件夹下的所有文件到b文件中cp a b -r:拷贝a文件夹到b文件中cp *.t?t b:拷贝所有以.t?t结尾的文件到b文件夹下 剪切文件：mv 命令说明-f 禁止交互式操作，如有覆盖也不会给出提示-i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件-v 显示移动进度eg:mv a b:mv a整体文件夹到b文件夹里面去mv a/* b:mv a文件夹下的所有文件到b文件夹里面去mv 1.tyt 1.txt:相当于重命名1.tyt 打包压缩 打包：tar -cvf Test.tar * 解包：tar -xvf Test.tar 压缩：gzip Test.tar 解压缩：gzip -d Test.tar.gz 打包压缩：tar -zcvf test.tar.gz * 解压缩：tar -zxvf test.tar.gz 解压缩到指定文件：tar -zxvf test.tar.gz -C chen/ bzip2打包压缩：tar -jcvf test.tar.bz2 * bzip2解压缩：tar -zxvf test.tar.bz2]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
